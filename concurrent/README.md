## マルチスレッドに関して
まずは、 Java がメモリ上でどのように動作しているのかを確認する。

### プロセスとスレッド
 - プロセス：各 Java アプリケーションに対してメモリ上に割り当てられた「メモリ空間」で動作する処理単位
 - スレッド：プロセス上で一行ずつコードを実行する一連のプログラムの処理
 - マルチプロセス：複数のプロセスが同時に動作すること
 - マルチスレッド：複数のスレッドが同時に実行されること
「メモリ空間」には、プログラムを実行するための様々なデータが格納される。プロセス間ではメモリ空間は共有されないが、スレッド間ではメモリ空間が共有される。つまり、異なるスレッド間で同一のデータにアクセスすることが可能。

### スレッドのライフサイクル
 1. 生成
    - new 演算子により、スレッドオブジェクトが生成される。生成段階では、まだスレッドオブジェクトにシステムリソースは割り当てられない。
 2. 実行可能
    - start メソッドの実行により、スレッドは実行可能状態になる。この状態になって初めて、スレッドオブジェクトにシステムリソースが割り当てられる。
 3. 実行
    - Java を実行するシステムのスケジュール機能に従い、（CPUが1つの場合）実行可能状態にあるスレッドのうち1つが実行される。このとき、run メソッドが実行される。
 4. 実行不可
    - 何らかの処理により、実行状態にあるスレッドが実行不可になる。この間、他のスレッドが実行状態になる。
    - 例）sleep、wait、入出力ブロック、ロック
 5. 終了
    - rum メソッドに記述した処理が完了した時点で、スレッドも終了する。１度終了したスレッドを再び実行することはできない。

### スレッド処理の種類
 - 逐次(Sequencial)：一つのプロセスで複数のスレッドを順番に処理すること
 - 並列(Parallel)：複数のプロセスで各々のスレッドを同時に処理すること
 - 並行(Concurrent)：一つのプロセスで複数のスレッドを切り替えながら動作させることで、擬似的に複数のスレッドを同時に処理すること
逐次処理はシングルスレッドに該当する。並列処理・並行処理は、マルチスレッドに該当する。<br>
並行処理の場合、スレッド間でメモリ空間を共有するため、考慮が必要。

### レースコンディション(race condition)
同時にアクセスされることを想定していなかったデータに対して、実際には複数スレッドから並行でアクセスされたことにより生じるバグを「レースコンディション」と呼ぶ。<br>
また、プログラムにおいてシングルスレッドで動作させる必要がある範囲を「クリティカルセクション」と呼ぶ。<br>
一方、複数のスレッドから同時に呼び出されても正常に動作するプログラムを「スレッドセーフ」と表現する。

### スレッドセーフな変数はローカル変数のみ
 - ローカル変数：メソッド内に記述し、各メソッド、コンストラクタの状態を定義する変数。スレッド固有の「スタック領域」にデータが格納される。そのため、一つのスレッドからしかアクセスができず、スレッドセーフである。
 - インスタンス変数：メソッドの外に記述し、他のメソッド、コンストラクタからも参照できる変数。同一クラス内の任意のメソッドから参照可能。複数のスレッドで共有される「ヒープ領域」にデータが保持されるため、他のスレッドからもデータを参照可能。
 - クラス変数：インスタンス変数にstatic修飾子が付与された変数。同一クラスの複数のインスタンス間で値が共有される。複数のスレッドで共有される「ヒープ領域」にデータが保持されるため、他のスレッドからもデータを参照可能。

### Java 8標準の並列APIとサンプルプログラムの対応
 - Thread (SimpleThread.java)
 - Executor framework (ExecutorFramework.java)
 - Fork/Join (ForkJoin.java)
 - CompletableFuture (CompletableFutureSample.java)
 - ParallelStream (ParallelStreamSample.java)

### アムダールの法則
並列化しても問題の大きさが変化しないという前提と、問題には並列化できない部分があるという前提の上で、逐次的アルゴリズムとそれに対応したアルゴリズムの並列化実装によって期待できる高速化の関係をモデル化したもの。<br>
以下の式で表現される。<br>
S(N) = 1/((1-P) + P/N)<br>
 - P : 並列化できる仕事の割合
 - N : 並列数
例えば、ある大きさの問題をあるアルゴリズムを並列化実装したもので実行した場合、問題の12%を並列化によって好きなように高速化できるとする（残り88%は並列化できない処理である）。アムダールの法則によれば、このときの並列化していない実装と比較した並列化版による高速化は最大でも(1/(1-0.12))=1.136 倍にしかならない。<br>
元々の処理時間を1とすると、N個のコアで分散した場合の時間は、「並列化できない部分」+「並列化できる部分」になるため、 (1-p)+p/n になる。つまり、比は 1 : ((1-p)+p/n) になる。nを無限に増やしても、 1 : (1-p) に収束するため、限界がある、ということ。